# P7 流水线设计文档

### 1.1 F级设计

#### 1.1.1 F级设计综述

        F级的部件只有IM，输出当前PC对应指令、以及当前PC值加入流水。

#### 1.1.2 F级涉及元件介绍

##### IM

| 信号                | 信号方向 | 功能                |
| ----------------- | ---- | ----------------- |
| clk               | IN   | 时钟信号              |
| reset             | IN   | 同步复位信号            |
| enable            | IN   | 使能信号，在阻塞的时候用于冻结PC |
| Req               | IN   | 时钟信号              |
| eret              | IN   | 同步复位信号            |
| NPC[31:0]         | IN   | 当前PC值             |
| PC[31:0]          | OUT  | 加入流水的PC值          |


### 1.2 D级设计

#### 1.2.1 D级设计综述

        在D级中元件包括GRP，EXT， NPC，CMP，在D级外部需要考虑来自E，M，W的转发。以及在需要阻塞的时候，产生阻塞信号，使D级寄存器暂停（取消使能信号1周期），E级寄存器复位，IM中PC冻结（取消使能信号1周期）
        控制信号上，采用分布式译码，控制信号以及阻塞信号的处理将在下一章单独处理

#### 1.1.2 D级涉及元件介绍

##### D_reg ： FD级流水寄存器

| 信号                  | 信号方向 | 功能                  |
| ------------------- | ---- | ------------------- |
| clk                 | IN   | 时钟信号                |
| reset               | IN   | 同步复位信号              |
| enable              | IN   | 使能信号，在阻塞的时候用于冻结内容   |
| F_PC[31:0]          | IN   | F级传入的PC值            |
| F_instruction[31:0] | IN   | F级传入的Instruction机器码 |
| D_PC[31:0]          | OUT  | 传入D级的PC值            |
| D_instruction[31:0] | OUT  | 传入D级的Instruction机器码 |

##### GRP   :    读取、回写寄存器堆

| 信号        | 信号方向 | 功能                  |
| --------- | ---- | ------------------- |
| clk       | IN   | 时钟信号                |
| reset     | IN   | 同步复位信号              |
| WD[31:0]  | IN   | 写入A3的内容             |
| PC[31:0]  | IN   | F级传入的PC值            |
| A1[4:0]   | IN   | rs寄存器地址             |
| A2[4:0]   | IN   | rt寄存器地址             |
| A3[4:0]   | IN   | 写入寄存器地址             |
| RD1[31:0] | OUT  | 从A1地址直接读出的数据，需要转发处理 |
| RD2[31:0] | OUT  | 从A2地址直接读出的数据，需要转发处理 |

##### CMP   :    处理Beq等一系列条件信号

| 信号         | 信号方向 | 功能                 |
| ---------- | ---- | ------------------ |
| clk        | IN   | 时钟信号               |
| reset      | IN   | 同步复位信号             |
| WD[31:0]   | IN   | 写入A3的内容            |
| PC[31:0]   | IN   | F级传入的PC值           |
| jump_allow | OUT  | beq等条件跳转立即数指令的控制信号 |

##### NPC   :    获得下一条指令的PC地址

| 信号          | 信号方向 | 功能            |
| ----------- | ---- | ------------- |
| D_PC[31:0]  | IN   | 写入A3的内容       |
| F_PC[31:0]  | IN   | F级传入的PC值      |
| Imm16[15:0] | IN   | 读出的16位立即数     |
| Imm26[25:0] | IN   | 读出的26位立即数     |
| rs[31:0]    | IN   | 跳转到的寄存器值      |
| op[2:0]     | IN   | PC值改变方式控制信号   |
| jump_allow  | IN   | 是否跳转立即数指令判断信号 |
| PC          | OUT  | 下一条指令的PC值     |

##### EXT   :       16位立即数拓展器

| 信号              | 信号方向 | 功能          |
| --------------- | ---- | ----------- |
| op              | IN   | 符号拓展还是无符号拓展 |
| Imm16[15:0]     | IN   | 读出的16位立即数   |
| EXTresult[31：0] | OUT  | 位拓展的结果      |

##### CMP   :       比较器,用于产生条件跳转（和、或）条件链接的使能信号

| 信号         | 信号方向 | 功能         |
| ---------- | ---- | ---------- |
| SrcA[31：0] | IN   | rs转发后数据    |
| SrcB[31：0] | IN   | rt转发后数据    |
| op[2:0]    | IN   | 判断方式选择信号   |
| allow      | OUT  | 跳转/链接的使能信号 |

### 1.3 E级设计

#### 1.3.1 E级设计综述

    在E级中元件包括ALU、MD乘除法运算器以及DE级寄存器，需要考虑来自W,M级的数据转发问题,以及乘除法产生的指令延迟。

#### 1.1.2 E级涉及元件介绍

##### E_reg ： DE级流水寄存器

| 信号                  | 信号方向 | 功能                   |
| ------------------- | ---- | -------------------- |
| clk                 | IN   | 时钟信号                 |
| reset               | IN   | 同步复位信号,在阻塞的时候需要设位高电平 |
| enable              | IN   | 使能信号                 |
| D_PC[31:0]          | IN   | D级传入的PC值             |
| D_instruction[31:0] | IN   | D级传入的Instruction机器码  |
| D_RD1[31:0]         | IN   | D级传入的rs寄存器数据         |
| D_RD2[31:0]         | IN   | D级传入的rt寄存器数据         |
| D_EXT[31:0]         | IN   | D级传入的16位立即数位拓展后的数据   |
| D_condition_link    | IN   | D级传入的条件链接判断信号        |
| E_PC[31:0]          | OUT  | 传入E级的PC值             |
| E_instruction[31:0] | OUT  | 传入E级的Instruction机器码  |
| E_RD1[31:0]         | OUT  | 传入E级的rs寄存器数据         |
| E_RD2[31:0]         | OUT  | 传入E级的rt寄存器数据         |
| E_EXT[31:0]         | OUT  | 传入E级的16位立即数位拓展后的数据   |
| E_condition_link    | OUT  | 传入E级的条件链接判断信号        |

##### ALU ： 运算器

| 信号         | 方向  | 功能                               |
| ---------- | --- | -------------------------------- |
| SrcA[31:0] | IN  | 运算数A                             |
| SrcB[31:0] | IN  | 运算数B                             |
| op[2:0]    | IN  | 控制信号                             |
| ALUresult  | OUT | 运算结果 |

##### MD ： 乘除法运算器

| 信号         | 方向  | 功能                               |
| ---------- | --- | -------------------------------- |
| clk                 | IN   | 时钟信号                 |
| reset               | IN   | 同步复位信号,在阻塞的时候需要设位高电平 |
| SrcA[31:0] | IN  | 运算数A                             |
| SrcB[31:0] | IN  | 运算数B                             |
| op[3:0]    | IN  | 控制信号                             |
| Start | IN  |  乘除法开始信号                             |
| Busy  | OUT |  乘除法运算阻塞信号 |
| MDresult  | OUT | 运算结果 |
| LO[31:0]  | OUT | LO寄存器结果 |
| HI[31:0]  | OUT | HI寄存器结果 |


### 1.4 M级设计

#### 1.4.1 M级设计综述

    在M级中元件包括BE、DE以及EM级寄存器，需要考虑来自W级的数据转发问题

#### 1.4.2 M级涉及元件介绍

##### M_reg ： EM级流水寄存器

| 信号                  | 信号方向 | 功能                   |
| ------------------- | ---- | -------------------- |
| clk                 | IN   | 时钟信号                 |
| reset               | IN   | 同步复位信号,在阻塞的时候需要设位高电平 |
| enable              | IN   | 使能信号                 |
| E_PC[31:0]          | IN   | E级传入的PC值             |
| E_instruction[31:0] | IN   | E级传入的Instruction机器码  |
| E_RD2[31:0]         | IN   | E级传入的rt寄存器数据         |
| E_ALUresult[31:0]       | IN   | E级传入的ALU结果   |
| E_condition_link    | IN   | E级传入的条件链接判断信号        |
| M_PC[31:0]          | OUT  | 传入M级的PC值             |
| M_instruction[31:0] | OUT  | 传入M级的Instruction机器码  |
| M_RD2[31:0]         | OUT  | 传入M级的rt寄存器数据         |
| M_ALUresult[31:0]         | OUT  | 传入M级的ALU结果   |
| M_condition_link    | OUT  | 传入M级的条件链接判断信号        |

##### BE ： store类指令处理模块

| 信号         | 方向  | 功能                               |
| ---------- | --- | -------------------------------- |
| op[1:0] | IN  | store指令的类型                             |
| Addr[1:0] | IN  | store指令的存储地址                              |
| WD[31:0] | IN  | 输入DM的数据                              |
| m_data_byteen[3:0]         | OUT  | 传入DM的使能信号         |
| m_data_wdata[31:0]         | OUT  | 传入DM的数据   |

##### DE ： load类指令处理模块

| 信号         | 方向  | 功能                               |
| ---------- | --- | -------------------------------- |
| op[1:0] | IN  | store指令的类型                             |
| Addr[1:0] | IN  | store指令的存储地址                              |
| m_data_rdata[31:0]         | IN  | 传回cpu的数据         |
| DE_RD[31:0]         | OUT  | load指令输出结果   |


### 1.4 M级设计

#### 1.4.1 W级涉及元件介绍

##### W_reg ： MW级流水寄存器

| 信号                  | 信号方向 | 功能                   |
| ------------------- | ---- | -------------------- |
| clk                 | IN   | 时钟信号                 |
| reset               | IN   | 同步复位信号,在阻塞的时候需要设位高电平 |
| enable              | IN   | 使能信号                 |
| M_PC[31:0]          | IN   | M级传入的PC值             |
| M_instruction[31:0] | IN   | M级传入的Instruction机器码  |
| M_RD[31:0]         | IN   |M级传入的DM读取数据         |
| M_ALUresult[31:0]       | IN   | M级传入的ALU结果   |
| M_condition_link    | IN   | M级传入的条件链接判断信号        |
| W_PC[31:0]          | OUT  | 传入W级的PC值             |
| W_instruction[31:0] | OUT  | 传入W级的Instruction机器码  |
| W_RD[31:0]         | OUT  | 传入W级的DM读取数据         |
| W_ALUresult[31:0]         | OUT  | 传入W级的ALU结果   |
| W_condition_link    | OUT  | 传入W级的条件链接判断信号        |

## 转发和阻塞的思考

### 转发
        assign M_rd2_afterforward =  (M_rt == 5'b0)        ? 32'b0     :
                                     (M_rt == W_GRFAddr)        ? W_GRFData : 
                                      M_rd2_beforeforward;
        assign E_rd1_afterforward =  (E_rs == 5'b0)      ? 32'b0     :
                                     (E_rs == M_GRFAddr) ? M_GRFData :
                                     (E_rs == W_GRFAddr) ? W_GRFData : E_rd1_beforeforward;
        assign E_rd2_afterforward =  (E_rt == 5'b0)      ? 32'b0     :
                                     (E_rt == M_GRFAddr) ? M_GRFData :
                                     (E_rt == W_GRFAddr) ? W_GRFData : E_rd2_beforeforward;
        assign D_rd1_afterforward = (D_rs == 5'b0)      ? 32'b0     :
                                    (D_rs == E_GRFAddr) ? E_GRFData : 
                                    (D_rs == M_GRFAddr) ? M_GRFData :
                                    (D_rs == W_GRFAddr) ? W_GRFData : D_rd1_beforeforward;
     
        assign D_rd2_afterforward = (D_rt == 5'b0)      ? 32'b0     :
                                    (D_rt == E_GRFAddr) ? E_GRFData : 
                                    (D_rt == M_GRFAddr) ? M_GRFData : 
                                    (D_rt == W_GRFAddr) ? W_GRFData : D_rd2_beforeforward;  

### 阻塞
Tuse 是指从D级开始，第一次使用寄存器数据的时间(X = 2)
| Tuse                  | RS | RT                   |
| ------------------- | ---- | -------------------- |
| branch                 | 0   |       0           |
| jr               | 0   | X | 
| r_cal except sll              | 1   |        1          |
| load | 1   |  X |
| store | 1   | 2 |
| i_cal except lui          | 1  |      2        |
| sll | 2   | 1  |
| lui | X   |  2|
| jal | X   |  X|

Tnew 表示目标数据还有多长时间产生，会随着数据的流水动态的减少。
考虑到W级Tnew必定是0，所以如果发生数据冒险，一定是转发处理
| Tnew                  | E | M                   |
| ------------------- | ---- | -------------------- |
| branch                 |  0  |    0              |
| jr               |   0 | 0 | 
| r_cal except sll              |  1  |  0                |
| i_cal except lui          |  1  |   0           |
| load |  2  | 1 |
| store |  0  | 0 |
| sll |  1  | 0  |
| lui |  1  |  0 |
| jal | 0   |  0 |

Tnew > Tuse -> 阻塞

Tnew <= Tuse -> 转发

### CP0协处理器
CP0协处理器

协处理器 0，包含 4 个 32 位寄存器，用于支持中断和异常。

#### 端口定义

| 端口  | 输入/输出 | 位宽  | 描述  |
| --- | --- | --- | --- |
| A1  | I   | 5   | 指定 4 个寄存器中的一个，将其存储的数据读出到 RD |
| A2  | I   | 5   | 指定 4 个寄存器中的一个，作为写入的目标寄存器 |
| Din | I   | 32  | 写入寄存器的数据信号 |
| PC  | I   | 32  | 目前传入的下一个 EPC 值 |
| ExcCodeIn | I   | 5   | 目前传入的下一个 ExcCode 值 |
| isInDelaySlot | I   | 32  | 目前传入的下一个 BD 值 |
| HWInt | I   | 6   | 外部硬件中断信号 |
| WE  | I   | 1   | 写使能信号，高电平有效 |
| EXLClr | I   | 1   | 传入 eret 指令时将 SR 的 EXL 位置 0 ，高电平有效 |
| clk | I   | 1   | 时钟信号 |
| reset | I   | 1   | 同步复位信号 |
| Req | O   | 1   | 输出当前的中断请求 |
| EPCOut | O   | 32  | 输出当前 EPC 寄存器中的值 |
| Dout | O   | 32  | 输出 A 指定的寄存器中的数据 |
| TestIntResponse | O   | 1   | 检测CPU是否对外部中断产生响应，从而决定是否去写`0x0000_7f20` |

### Bridge

系统桥是处理CPU与外设（两个计时器）之间信息交互的通道

CPU中store类指令需要储存的数据经过BE处理后会通过m_data_addr, m_data_byteen, m_data_wdata三个信号输出到桥中，桥会根据写使能m_data_byteen和地址m_data_addr来判断到底写的是内存还是外设，然后给出正确的写使能

load类指令则是全部把地址传递给每个外设和DM中，然后桥根据地址选择从应该反馈给CPU从哪里读出来的数据，然后DE在处理读出的数据，反馈正确的结果

端口已经在教程中给出，不再赘述（偷懒）

## 思考题

### 1、请查阅相关资料，说明鼠标和键盘的输入信号是如何被 CPU 知晓的？
1） 键盘

键盘由一组开关矩阵组成，包括数字键、字母键、符号键、功能键及控制键等。每一个按键在计算机中都有它的惟一代码。当按下某个键时，键盘接口将该键的二进制代码送入计算机主机中，并将按键字符显示在显示器上。当快速大量输入字符，主机来不及处理时，先将这些字符的代码送往内存的键盘缓冲区，然后再从该缓冲区中取出进行分析处理。键盘接口电路多采用单片微处理器，由它控制整个键盘的工作，如上电时对键盘的自检、键盘扫描、按键代码的产生、发送及与主机的通讯等。

（2） 鼠标

鼠标是一种手持式屏幕坐标定位设备，它是适应菜单操作的软件和图形处理环境而出现的一种输入设备，特别是在现今流行的Windows图形操作系统环境下应用鼠标器方便快捷。常用的鼠标器有两种，一种是机械式的，另一种是光电式的。

机械式鼠标器的底座上装有一个可以滚动的金属球，当鼠标器在桌面上移动时，金属球与桌面摩擦，发生转动。金属球与四个方向的电位器接触，可测量出上下左右四个方向的位移量，用以控制屏幕上光标的移动。光标和鼠标器的移动方向是一致的，而且移动的距离成比例。

光电式鼠标器的底部装有两个平行放置的小光源。这种鼠标器在反射板上移动，光源发出的光经反射板反射后，由鼠标器接收，并转换为电移动信号送入计算机，使屏幕的光标随之移动。其他方面与机械式鼠标器一样。

鼠标器上有两个键的，也有三个键的。最左边的键是拾取键，最右边的键为消除键，中间的键是菜单的选择键。由于鼠标器所配的软件系统不同，对上述三个键的定义有所不同。一般情况下，鼠标器左键可在屏幕上确定某一位置，该位置在字符输入状态下是当前输入字符的显示点；在图形状态下是绘图的参考点。在菜单选择中，左键（拾取键）可选择菜单项，也可以选择绘图工具和命令。当作出选择后系统会自动执行所选择的命令。鼠标器能够移动光标，选择各种操作和命令，并可方便地对图形进行编辑和修改，但却不能输入字符和数字。

### 2、请思考为什么我们的 CPU 处理中断异常必须是已经指定好的地址？如果你的 CPU 支持用户自定义入口地址，即处理中断异常的程序由用户提供，其还能提供我们所希望的功能吗？如果可以，请说明这样可能会出现什么问题？否则举例说明。（假设用户提供的中断处理程序合法）

如果用户可以任意选择中断处理地址，不同软件会因为异常处理，可能跳转到另一个软件正常地址，将会不兼容。

### 3、为何与外设通信需要 Bridge？

通过bridge并且约定某段内存地址对应于某个外设，这样我们就只需要通过访存去实现与外设的联系，指令集会比较的简洁。添加外设时，外设也只需要体现在入口地址的不同而不需要改变CPU的内部结构，让CPU访问外设只需通过地址，这样也是体现了”高内聚，低耦合”的原则。

### 4、请阅读官方提供的定时器源代码，阐述两种中断模式的异同，并分别针对每一种模式绘制状态移图。
计数器模式 0：
![Alt text](image.png)
计数器模式 1：
![Alt text](5df6034755739386fc1bc96b40db612.png)
### 5、倘若中断信号流入的时候，在检测宏观 PC 的一级如果是一条空泡（你的 CPU 该级所有信息均为空）指令，此时会发生什么问题？在此例基础上请思考：在 P7 中，清空流水线产生的空泡指令应该保留原指令的哪些信息？
写入EPC会出错，延迟槽标记信号也会出错。
如果是中断或者异常而清空流水线，应该保持原有的PC值，以保证宏观PC的正确。
如果是阻塞而清空流水线，应该要保持原有的PC并且保持原有的BD标志信号。
### 6、为什么 jalr 指令为什么不能写成 jalr $31, $31？
这种操作会导致CPU不知道先跳转还是先链接，产生冲突。